<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>js知识点（持续扩展） | 送你回家</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="图片懒加载引用源文 - 什么叫图片懒加载？当访问一个页面的时候，先把img元素或是其他元素的背景图路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内，才设置图片真正的路径，让图片显示出来，这就是图片懒加载。 - 为什么要使用这个技术？如果一个页面中有很多图片，一上来就发送那么多请求，页面加载就会很漫长。如果js文件都放在了文档的底部，恰巧页面的头">
<meta property="og:type" content="article">
<meta property="og:title" content="JS知识点（持续扩展）">
<meta property="og:url" content="http://yoursite.com/2018/04/18/JS常见面试题/index.html">
<meta property="og:site_name" content="送你回家">
<meta property="og:description" content="图片懒加载引用源文 - 什么叫图片懒加载？当访问一个页面的时候，先把img元素或是其他元素的背景图路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内，才设置图片真正的路径，让图片显示出来，这就是图片懒加载。 - 为什么要使用这个技术？如果一个页面中有很多图片，一上来就发送那么多请求，页面加载就会很漫长。如果js文件都放在了文档的底部，恰巧页面的头">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://imgsa.baidu.com/forum/w%3D580/sign=4dfad5bbd31373f0f53f6f97940d4b8b/4beffffe9925bc31c0d94c585cdf8db1ca137000.jpg">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/8542482-ccfbae49588870d7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/8542482-62fa73ee3afc69cf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/8542482-8cc5795fed1e4d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/8542482-42aad8702ce073e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-04-26T06:48:39.902Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS知识点（持续扩展）">
<meta name="twitter:description" content="图片懒加载引用源文 - 什么叫图片懒加载？当访问一个页面的时候，先把img元素或是其他元素的背景图路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内，才设置图片真正的路径，让图片显示出来，这就是图片懒加载。 - 为什么要使用这个技术？如果一个页面中有很多图片，一上来就发送那么多请求，页面加载就会很漫长。如果js文件都放在了文档的底部，恰巧页面的头">
<meta name="twitter:image" content="https://imgsa.baidu.com/forum/w%3D580/sign=4dfad5bbd31373f0f53f6f97940d4b8b/4beffffe9925bc31c0d94c585cdf8db1ca137000.jpg">
  
    <link rel="alternate" href="/atom.xml" title="送你回家" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-JS常见面试题" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      JS知识点（持续扩展）
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/04/18/JS常见面试题/" class="article-date">
	  <time datetime="2018-04-17T16:00:00.000Z" itemprop="datePublished">2018-04-18</time>
	</a>

      
    <a class="article-category-link" href="/categories/小Tips/">小Tips</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=4dfad5bbd31373f0f53f6f97940d4b8b/4beffffe9925bc31c0d94c585cdf8db1ca137000.jpg" alt="2018/4/18 晴天"></p>
<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title=" 图片懒加载"></a><center> 图片懒加载</center></h3><p><center><a href="https://www.cnblogs.com/flyromance/p/5042187.html" target="_blank" rel="noopener">引用源文</a></center></p>
<h5 id="什么叫图片懒加载？"><a href="#什么叫图片懒加载？" class="headerlink" title="- 什么叫图片懒加载？"></a>- 什么叫图片懒加载？</h5><p>当访问一个页面的时候，先把img元素或是其他元素的背景图路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内，才设置图片真正的路径，让图片显示出来，这就是图片懒加载。</p>
<h5 id="为什么要使用这个技术？"><a href="#为什么要使用这个技术？" class="headerlink" title="- 为什么要使用这个技术？"></a>- 为什么要使用这个技术？</h5><p>如果一个页面中有很多图片，一上来就发送那么多请求，页面加载就会很漫长。如果js文件都放在了文档的底部，恰巧页面的头部又依赖这个js文件，那就凉凉了；最重要的是，这么多的请求，服务器可能会吃不消。</p>
<h5 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="- 怎么实现？"></a>- 怎么实现？</h5><ul>
<li>页面中的ig元素，如果没有src属性，浏览器就不会发出请求去下载图片，一旦通过js设置了图片路径，浏览器才会发送请求。（有点按需分配的意思）</li>
<li>把真正的路径存在元素的“data-url”（自己取个名字）属性里，要用的时候就取出来，再设置。</li>
<li>获取某个元素的尺寸大小、滚动条滚动距离以及偏移位置距离的方法：<ul>
<li>屏幕可视窗口大小：<br>原生方法：window.innerHeight 标准浏览器及IE9 || document.documentElement.scrollTop标准浏览器及低版本IE标准模式|| document.body.clientHeight 低版本混杂模式<br>jQuery方法：$(window).height()</li>
<li>浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的高度<br>　　 原生方法：window.pagYoffset——IE9+及标准浏览器 || document.documentElement.scrollTop 兼容ie低版本的标准模式 || document.body.scrollTop 兼容混杂模式；<br>  jQuery方法：$(document).scrollTop(); </li>
</ul>
</li>
</ul>
<p>　  - 获取元素的尺寸，左边jquery方法，右边原生方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(o).width() = o.style.width; </span><br><span class="line"></span><br><span class="line">$(o).innerWidth() = o.style.width+o.style.padding;</span><br><span class="line"></span><br><span class="line">$(o).outerWidth() = o.offsetWidth = o.style.width+o.style.padding+o.style.border;</span><br><span class="line"></span><br><span class="line">$(o).outerWidth(true) = o.style.width+o.style.padding+o.style.border+o.style.margin;</span><br></pre></td></tr></table></figure></p>
<p>　　　　注意：要使用原生的style.xxx方法获取属性，这个元素必须已经有内嵌的样式，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;....&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　　　如果原先是通过外部或内部样式表定义css样式，必须使用以下方法来获取样式值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.currentStyle[xxx] || document.defaultView.getComputedStyle(0)[xxx]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获取元素的位置信息</li>
</ul>
<p>　　1 返回元素相对于文档document顶部、左边的距离；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　jQuery：$(o).offset().top元素距离文档顶的距离，$(o).offset().left元素距离文档左边缘的距离</span><br></pre></td></tr></table></figure></p>
<p>　原生：getoffsetTop()返回的元素相对于第一个以定位的父元素的偏移距离，注意与上面偏移距的区别；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery：position()返回一个对象，$(o).position().left = style.left，$(o).position().top = style.top；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如何判断某个元素进入或者即将进入可视窗口区域？<br>就是根据对象的边界与可视窗口边界相对距离的大小来判断。</li>
</ul>
<h3 id="事件委托和事件捕获"><a href="#事件委托和事件捕获" class="headerlink" title=" 事件委托和事件捕获"></a><center> 事件委托和事件捕获</center></h3><p><center><a href="https://www.jianshu.com/p/f937db28b007" target="_blank" rel="noopener">阻止事件委托和事件捕获</a></center></p>
<p><center><a href="https://blog.csdn.net/u013035060/article/details/60770477" target="_blank" rel="noopener">源文来源</a></center></p>
<h5 id="概述"><a href="#概述" class="headerlink" title=" 概述"></a><center> 概述</center></h5><p><right>事件委托还有一个名字叫事件代理，利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。举个例子更生动：<br>有三个同事预计会在周一收到快递，为签收快递，有两种方法：一是三个人在公司门口等快递；二是委托给前台MM签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</right></p>
<ul>
<li>为什么要用事件委托：<br>避免多次DOM操作，减少dom与页面的交互次数，提高性能，节省空间。</li>
</ul>
<h5 id="事件委托的原理："><a href="#事件委托的原理：" class="headerlink" title=" 事件委托的原理："></a><center> 事件委托的原理：</center></h5><p><center>利用事件的冒泡，（什么是事件冒泡呢：就是事件从最深的节点开始，然后逐步向上传播事件）</center></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">传统的li实现点击功能：</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi = oUl.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">    for(var i=0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">        aLi[i].onclick = function()&#123;</span><br><span class="line">            alert(123);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">通过遍历所有的Li绑定好点击事件。</span><br><span class="line"></span><br><span class="line">接下来是利用事件委托：</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">   oUl.onclick = function()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件</span><br><span class="line">就会被触发。如果想让事件代理的效果跟直接给节点的事件效果一样时，我们还有一招：</span><br><span class="line"></span><br><span class="line">Event对象提供了一个属性叫target，可以返回事件的目标节点，标准浏览器用event.target，IE浏览器用</span><br><span class="line">event.srcElement，此时只是获取了当前节点的位置，并不知道什么节点名称，这里再用nodeName来获取具体</span><br><span class="line">是什么标签名，返回值是一个大写的字符串。</span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">　　oUl.onclick = function(ev)&#123;</span><br><span class="line">　　　　var ev = ev || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">　 　　　　　　 alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件捕获的执行顺序"><a href="#事件捕获的执行顺序" class="headerlink" title=" 事件捕获的执行顺序"></a><center> 事件捕获的执行顺序</center></h3><p>首先强调事件绑定时的兼容性写法：<br>IE8及更早版本需要用attachEvent()，正常版本用addEventListener()，对于兼容写法，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line"></span><br><span class="line">if (x.addEventListener) &#123;                    //所有主流浏览器，除了 IE 8 及更早 IE版本</span><br><span class="line"></span><br><span class="line">    x.addEventListener(&quot;click&quot;, myFunction);</span><br><span class="line"></span><br><span class="line">&#125; else if (x.attachEvent) &#123;                  // IE 8 及更早 IE 版本</span><br><span class="line"></span><br><span class="line">    x.attachEvent(&quot;onclick&quot;, myFunction);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">其中element.addEventListener(event，function，useCapture)方法中，event不要使用on前缀，function</span><br><span class="line">指定要事件触发时执行的函数；useCapture可选，是布尔值，指定事件是否在捕获或冒泡阶段执行。</span><br></pre></td></tr></table></figure></p>
<p>事件冒泡和事件捕获的过程正好相反，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;div1&quot;&gt;我是div1&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;div2&quot;&gt;我是div2&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;div3&quot;&gt;我是div3&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;div4&quot;&gt;我是div4&lt;/div&gt;</span><br><span class="line">var div1=document.getElementById(&quot;div1&quot;);</span><br><span class="line"></span><br><span class="line">var div2=document.getElementById(&quot;div2&quot;);</span><br><span class="line"></span><br><span class="line">var div3=document.getElementById(&quot;div3&quot;);</span><br><span class="line"></span><br><span class="line">var div4=document.getElementById(&quot;div4&quot;);</span><br><span class="line"></span><br><span class="line">div1.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line"></span><br><span class="line">alert(&quot;我是div1&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">div2.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line"></span><br><span class="line">alert(&quot;我是div2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">div3.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line"></span><br><span class="line">alert(&quot;我是div3&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">div4.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line"></span><br><span class="line">alert(&quot;我是div4&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">当所有的Li标签绑定的事件的useCapture都是true，则点击第四个div时，会依次显示1-2-3-4，而如果是冒泡的</span><br><span class="line">话，显示的结果应该是4-3-2-1</span><br><span class="line"></span><br><span class="line">如果一个dom元素中，既有冒泡，又有捕获的话，会这么执行呢？W3C规定，任何发生在W3C模型中的事件，首先</span><br><span class="line">进入捕获阶段，直到达到目标元素，再进入冒泡阶段。</span><br></pre></td></tr></table></figure>
<h3 id="JS数组方法"><a href="#JS数组方法" class="headerlink" title=" JS数组方法"></a><center> JS数组方法</center></h3><p><br></p>
<h5 id="join"><a href="#join" class="headerlink" title=" join()"></a><center> join()</center></h5><p><center>Array.join()是string.split()的逆向操作</center></p>
<h5 id="reverse"><a href="#reverse" class="headerlink" title=" reverse()"></a><center> reverse()</center></h5><p><center>将数组元素全部倒过来</center></p>
<h5 id="sort"><a href="#sort" class="headerlink" title=" sort()"></a><center> sort()</center></h5><p><center>排序，可以在括号里写排序的规则</center></p>
<h5 id="cancat"><a href="#cancat" class="headerlink" title=" cancat()"></a><center> cancat()</center></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1，2，3];</span><br><span class="line">arr.concat(4,5);</span><br><span class="line">得到一个新的数组arr = [1，2，3，4，5]</span><br></pre></td></tr></table></figure>
<h5 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title=" slice(start,end)"></a><center> slice(start,end)</center></h5><p><center>返回数组片段，不需要变量接收</center></p>
<h5 id="splice"><a href="#splice" class="headerlink" title=" splice()"></a><center> splice()</center></h5><p><center> 删除，插入，替换。<br>这个方法的功能很多，参数的不同决定功能的不同；</center></p>
<h5 id="删除的用法，array-splice-starti-n-，其中starti的含义是从哪个位置开始，n指的是需要删除的个数。"><a href="#删除的用法，array-splice-starti-n-，其中starti的含义是从哪个位置开始，n指的是需要删除的个数。" class="headerlink" title="删除的用法，array.splice(starti,n)，其中starti的含义是从哪个位置开始，n指的是需要删除的个数。"></a>删除的用法，array.splice(starti,n)，其中starti的含义是从哪个位置开始，n指的是需要删除的个数。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">    var array=[1,2,3,4,5];  </span><br><span class="line">    array.splice(3,2);  </span><br><span class="line">    console.log(array);  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">得到的结果是：[1,2,3]，这里被删除的元素其实可以用一个变量来接收</span><br></pre></td></tr></table></figure>
<h5 id="插入的用法，array-splice-starti，0，值1，值2……-，其中0表示删除0个元素，值1和值2表示需要插入的值。"><a href="#插入的用法，array-splice-starti，0，值1，值2……-，其中0表示删除0个元素，值1和值2表示需要插入的值。" class="headerlink" title="插入的用法，array.splice(starti，0，值1，值2……)，其中0表示删除0个元素，值1和值2表示需要插入的值。"></a>插入的用法，array.splice(starti，0，值1，值2……)，其中0表示删除0个元素，值1和值2表示需要插入的值。</h5><h5 id="替换的用法，array-splice-starti，n，值1，值2-，在需要替换的位置先删除，然后再插入值"><a href="#替换的用法，array-splice-starti，n，值1，值2-，在需要替换的位置先删除，然后再插入值" class="headerlink" title="替换的用法，array.splice(starti，n，值1，值2)，在需要替换的位置先删除，然后再插入值~"></a>替换的用法，array.splice(starti，n，值1，值2)，在需要替换的位置先删除，然后再插入值~</h5><p><br></p>
<h4 id="把数组当栈使用"><a href="#把数组当栈使用" class="headerlink" title=" 把数组当栈使用"></a><center> 把数组当栈使用</center></h4><p><center>push()，尾部添加</center></p>
<p><center>unshift()，头部添加</center></p>
<p><center>pop()，尾部删除</center></p>
<p><center>shift()，头部删除</center></p>
<ul>
<li>遍历<br>for…in…（除了可以遍历数组，还可以遍历对象的键值对）</li>
<li>indexof（）从左向右索引，<br>lastIndexof恰好相反，是从右向左索引。</li>
<li>数组去重<br>数组去重的方法很多，比如利用一个for循环，在里面用indexof的返回值来判断是否有重复，有的话就删除，没有的话继续；或者是两个循环遍历一次。很多方法~</li>
</ul>
<h3 id="实现拖拽功能"><a href="#实现拖拽功能" class="headerlink" title=" 实现拖拽功能"></a><center> 实现拖拽功能</center></h3><p><br><br>原理：<br>1 鼠标按下时，开始执行<br>2 鼠标按下后，鼠标开始移动时，需要拖拽的元素跟着一起移动<br>3 鼠标松开，然后停止移动<br>对应的三个事件就是：<br>1 onmousedown<br>2 onmousemove<br>3 onmouseup<br>在鼠标按下时，记录当前元素的位置newSite，同时设置一个标记，用来表示此时鼠标按下的状态，方便鼠标移动事件执行。<br>当鼠标松开时，我们要将标记改变，说明此时鼠标松开了，当鼠标移动时就不能再移动元素了。<br>当鼠标按下并且移动时，我们就要记录鼠标每次移动的位置currentSite，currentSite和newSite的差值就是鼠标移动的距离，同时也是元素应该移动的距离，然后设置元素的位置就可以了。<br>这里需要注意的是，需要移动的元素的Position属性应该设为absolute或者relative，这样元素才可以移动。<br>其中目标元素的初始位置都从CSS样式中提取。</p>
<h3 id="实现Gulp的功能"><a href="#实现Gulp的功能" class="headerlink" title=" 实现Gulp的功能"></a><center> 实现Gulp的功能</center></h3><p><br></p>
<p><center><a href="https://blog.csdn.net/qingyafan/article/details/52231383" target="_blank" rel="noopener">参考源文</a><br>前端优化中的一条是，尽量缩小js，html，css和图片等静态文件的尺寸，因为每个文件都将会有一个http请求，在下载的过程中，浏览器会停止所有手头工作，专心下载，直到完成，才会做其他事情。而gulp主要就是自动化压缩静态文件的工具。</center></p>
<ul>
<li>特点：1 相对于其他构建工具，gulp以“管道和文件流”的处理方式标榜自己。数据流是gulp的基础，读取磁盘文件流，处理文件流，最后将文件流写入磁盘文件，完成任务。管道的思想来源于Unix，举个例子，水在管道中，我把管道接到哪里，水就可以流到哪里，也就是说，我可以利用多根管道，让水流过多个地方，这样多个地方都可以用到水。<br>2 gulp的另一个特点是它的模块插件，其主张“每个模块插件只应该做一件事”，gulp只提供比较简单的基础功能，或者说“给它的插件提供一个平台”，大部分工作都是其插件在其提供的“平台”之上完成的。<br>#####- 内容<br>gulp一共有四个方法或者说API，</li>
<li><p>gulp.src(glob[s][,options])，读取磁盘文件，并返回文件流，glob是字符串表示的文件通配符，类似正则表达式，可以是字符串或者是glob数组。</p>
</li>
<li><p>gulp.dest(path[,options])，将管道中的文件流写入文件，因为我们可以使用多根管道，因此我们当然可以多次调用dest方法，path是写入文件的路径。</p>
</li>
<li><p>gulp.task(name[,deps],[,fn])，定义具体的任务，name是字符串类型的任务名，如果name是“default”，那么在命令行直接输入gulp，默认会执行这个任务；deps表示依赖的任务，是任务名字符串数组，也就是说deps任务执行完才会执行name任务；fn是执行完name指定的任务后的回调函数。</p>
</li>
<li><p>gulp.watch(glob[s][,options],tasks)或者gulp.watch(glob[,options,cb])，相当于一个观察者，一旦在其管辖下的文件有所变动，执行一个或多个任务，glob是字符串或者glob数组；watch有两种形式，tasks表示事件触发时要执行的任务数组，cb表示事件触发时的回调函数，传入回调函数的参数是事件对象，返回观察者对象，该对象可以监听change，end，ready，error，ready，nomatch事件。</p>
</li>
</ul>
<h5 id="常用功能及其插件"><a href="#常用功能及其插件" class="headerlink" title="- 常用功能及其插件"></a>- 常用功能及其插件</h5><p>1 gulp-jshint，检查js的错误<br>2 gulp-uglify，压缩js<br>3 gulp-minify-css，压缩css</p>
<ul>
<li>gulpfile配置文件<br>gulpfile是定义gulp任务的地方，它所遵循的commonjs规范和js文件模块并无二致，在gulpfile中定义的任务，我们可以在命令行中调用，调用语法为 gulp takename，如果不带taskname参数，默认执行名为default的任务。</li>
<li><p>gulp自动化实例<br>在gulpfile中引入需要的模块，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const gulp = require(&apos;gulp&apos;);</span><br><span class="line">const jshint = require(&apos;gulp-jshint&apos;);</span><br><span class="line">const uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line">const minifyCss = require(&apos;gulp-minify-css&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查语法或者其他错误（jshint）<br>检查 JavaScript 文件是否存在错误或者可能会引起错误的地方，例如一般比较应该使用===/!==代替==/!=，字符串换行拼接应在行末添加连接符+等等。gulp-jshint 并不能独自完成这项艰巨的任务，它依赖于真正的大将 jshint，gulp-jshint 只不过加了一层包裹，使之可以在 gulp 中使用，所以不仅应该安装 gulp-jshint 依赖，还应该添加 jshint 依赖：npm install –save-dev jshint gulp-jshint。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// check javascript error or warnning</span><br><span class="line">gulp.task(&apos;jshint&apos;, function() &#123;</span><br><span class="line">  gulp.src(&apos;./scripts/apps/*.js&apos;)</span><br><span class="line">      .pipe(&apos;jshint&apos;)</span><br><span class="line">      .pipe(jshint.reporter(&apos;default&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">执行 gulp jshint，看疗效如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/8542482-ccfbae49588870d7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>压缩JS文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// minify javascript file from apps folder to scripts/dist folder</span><br><span class="line">gulp.task(&apos;minifyjs&apos;, function() &#123;</span><br><span class="line">  gulp.src(&apos;./scripts/apps/*.js&apos;)</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(&apos;./scripts/dist&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>经过上面对 gulp API 的介绍，你应该能理解这段代码，定义一个名为‘minifyjs’的任务，可以在命令行通过 gulp minifyjs进行调用。任务首先读取 ./scripts/apps 文件夹中的所有以 .js 后缀结尾的文件，然后使用管道将流导入 uglify() 加工，最后再通过管道将加工好的流写入到 ./scripts/dist 文件夹中，名称不变，如果 ./scripts/dist 文件夹不存在，那么 gulp 会主动创建，如果 ./scripts/apps 文件夹不存在，那么 gulp 什么也不做，也不报错【笑】！执行效果如下:<br><img src="http://upload-images.jianshu.io/upload_images/8542482-62fa73ee3afc69cf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li><p>压缩合并CSS文件<br>css 压缩任务和 JavaScript 压缩任务几乎相同，就不多加解释了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// minify css file from css folder to css/dist folder</span><br><span class="line">gulp.task(&apos;minifycss&apos;, function() &#123;</span><br><span class="line">  gulp.src(&apos;./styles/*.css&apos;)</span><br><span class="line">      .pipe(minifyCss())</span><br><span class="line">      .pipe(gulp.dest(&apos;./styles/dist&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>监控代码改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;watchchange&apos;, function() &#123;</span><br><span class="line">  gulp.watch(&apos;./scripts/apps/*.js&apos;, [&apos;minifyjs&apos;]);</span><br><span class="line">  gulp.watch(&apos;./styles/*.css&apos;, [&apos;minifycss&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="promise的实现原理"><a href="#promise的实现原理" class="headerlink" title=" promise的实现原理"></a><center> promise的实现原理</center></h3><p><a href="https://mengera88.github.io/2017/05/15/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">资料源文</a></p>
<ul>
<li>什么是promise？<br>promise是把类似异步处理对象和处理规则进行规范化，并按照采用统一的接口来编写，而采取规定方法之外的写法都会报错。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var promise = http.get(&apos;/v1/get&apos;);</span><br><span class="line">promise.then(function(result) &#123;</span><br><span class="line">    //成功时的处理</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">    //错误时的处理</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们必须按照接口规定的方法编写处理代码。也就是说，除promise对象规定的方法(这里的 then 或 catch)以外的方法都是不可以使用的， 而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。这样，基于Promise的统一接口的做法， 就可以形成基于接口的各种各样的异步处理模式。<br>但这并不是使用promise的足够理由，promise为异步操作提供了统一的接口，能让代码不至于陷入回调嵌套的死路中，它的强大之处在于它的链式调用（文章后面会有提及）。</p>
<ul>
<li>基本用法<br>promise的语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve, reject) &#123;</span><br><span class="line">    //待处理的异步逻辑</span><br><span class="line">    //处理结束后，调用resolve或reject方法</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。<br>其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态：</p>
<p>1 pending: 初始状态，位履行或拒绝<br>2 fulfilled: 意味着操作成功完成<br>3 rejected: 意味着操作失败</p>
<p>pending 状态的 Promise对象可能以 fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数。<br><img src="http://upload-images.jianshu.io/upload_images/8542482-8cc5795fed1e4d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>简单的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // 如果调用了resolve方法，执行此函数</span><br><span class="line">&#125;, function(value) &#123;</span><br><span class="line">  // 如果调用了reject方法，执行此函数</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>promise的链式操作<br>Promise.prototype.then方法返回的是一个新的Promise对象，因此可以采用链式写法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/visa.json&quot;).then(function(json) &#123;</span><br><span class="line">  return json.name;</span><br><span class="line">&#125;).then(function(name) &#123;</span><br><span class="line">  // proceed</span><br><span class="line">&#125;);</span><br><span class="line">上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果前一个回调函数返回的是Promise对象，这时后一个回调函数就会等待该Promise对象有了运行结果，才会进一步调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/visa/get.json&quot;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.jobURL);</span><br><span class="line">&#125;).then(function(jobs) &#123;</span><br><span class="line">  // 对jobs进行处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的“横向发展”改为“向下发展”。</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title=" webpack"></a><center> webpack</center></h3><p><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">资料源文</a><br>webpack的功能就如它的官网所示——打包所有的资源、脚本、样式、图片。<br><img src="https://upload-images.jianshu.io/upload_images/8542482-42aad8702ce073e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM图片20180331222517.png"><br>注意下面的两句英文：依赖模型   和  静态资产</p>
<ul>
<li>首先理解四个核心概念<br>1 入口<br>2 输出<br>3 loader<br>4 插件</li>
</ul>
<p>#####1 入口<br>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。我们看一个 entry 配置的最简单例子：<br>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-出口"><a href="#2-出口" class="headerlink" title="2 出口"></a>2 出口</h5><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：<br>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Gulp和Webpack的区别：<br>gulp是基于流的构建工具：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。<br>webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、打包、按需加载等。<h3 id="浅克隆和深克隆和ES6的Symbol"><a href="#浅克隆和深克隆和ES6的Symbol" class="headerlink" title=" 浅克隆和深克隆和ES6的Symbol"></a><center> 浅克隆和深克隆和ES6的Symbol</center></h3><a href="https://juejin.im/post/5abd8ee1518825558a06b827" target="_blank" rel="noopener">资料来源</a></li>
<li>浅度克隆<br>js有六大数据类型：number，string，boolean，undefined，null，object<br>其中number，string，boolean，undefined，null归为原始值一类，而object属于引用值，具体包括狭义的object，array，function。<br>浅克隆在克隆对象和数组时会克隆它们的地址，之后改变目标时，克隆得到的结果也会随着操作而改变，因为他们指向的都是同一个空间，通过一个对象在这个空间里面加了东西，另一个对象也必然会受到影响。<br>而对于函数而言，通过上面这种普通的赋值拷贝，就可以实现，且互不影响，因为函数的克隆会在内存中单独开辟一块空间。</li>
</ul>
<p>-深度克隆<br>先整理一下思路：<br>1 遍历待拷贝的对象<br>2 判断每个元素是不是原始值，若是，则通过浅度克隆的手段进行拷贝<br>3 若是引用值，则需要继续判断是对象还是数组<br>4 再分别建立空数组或空对象用来盛放里面即将拷贝而来的属性值<br>5 数组和对象里面的若是原始值，则浅拷贝即可实现，若还有引用值，则还需要重复进行上述一系列的判断。</p>
<p>上述思路怎么用代码实现呢？<br>1 使用for in进行遍历。但需要注意的是，for in方法会把对象原型里的属性也一起遍历了，所以要与hasOwnProperty()方法进行联用，hasOwnProperty()方法可以判断某属性是不是该对象自己的属性，从而过滤掉原型中的属性。<br>2 用typeof()返回值来进行判断，数组和对象的typeof返回值是’object’<br>3 用toString（）方法来判断是对象还是数组<br>4 创建新的{}或者[]<br>5 重复判断，可以采用递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br><span class="line">function deepClone(origin, target) &#123;</span><br><span class="line">	var target = target || &#123;&#125;,</span><br><span class="line">		toStr = Object.prototype.toString,</span><br><span class="line">		arrStr = &apos;[object Array]&apos;;</span><br><span class="line">	for (var prop in origin) &#123;</span><br><span class="line">		if (origin.hasOwnProperty(prop)) &#123;</span><br><span class="line">			if (typeof (origin[prop]) == &apos;object&apos; &amp;&amp; origin[prop] !== null) &#123;</span><br><span class="line">				if (toStr.call(origin[prop]) == arrStr) &#123;</span><br><span class="line">					target[prop] = [];</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					target[prop] = &#123;&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				deepClone(origin[prop], target[prop]);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				target[prop] = origin[prop];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Aden_Z</span><br><span class="line">链接：https://juejin.im/post/5abd8ee1518825558a06b827</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<p>注意到origin[prop] !== null这句了么？为啥要加上它，因为typeof(null)也是’object’。</p>
<h5 id="针对ES6新增的Symbol类型来探讨一下浅拷贝和深拷贝"><a href="#针对ES6新增的Symbol类型来探讨一下浅拷贝和深拷贝" class="headerlink" title="- 针对ES6新增的Symbol类型来探讨一下浅拷贝和深拷贝"></a>- 针对ES6新增的Symbol类型来探讨一下浅拷贝和深拷贝</h5><p><a href="https://juejin.im/post/5a6f39df6fb9a01cab288733" target="_blank" rel="noopener">资料源文</a></p>
<ul>
<li>Symbol介绍<br>Symbol是ES6中引入的原始数据类型。Symbol值通过Symbol函数生成，是独一无二的。同时，ES6中规定了对象的属性名有两种类型，一种是字符串，另一种就是 Symbol 类型。凡是属性名属于 Symbol 类型，就不会与其他属性名产生冲突。<br>但是，随之而来的问题是，我们的for…in循环不能遍历出该属性。</li>
</ul>
<p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>有Symbol类型，自然有遍历Symbol类型的方法。Object.getOwnPropertySymbols + for…in的组合起来好像是能满足我们要求的了。<br>可是等等，还有一个方法——&gt;Reflect.ownKeys，该方法返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可以枚举。</p>
<p>总结：</p>
<p>######for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p>######Object.keys()返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p>######Object.getOwnPropertyNames()返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p>######Object.getOwnPropertySymbols()返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p>######Reflect.ownKeys()返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<h3 id="手写parseInt的实现："><a href="#手写parseInt的实现：" class="headerlink" title=" 手写parseInt的实现："></a><center> 手写parseInt的实现：</center></h3><p><a href="http://www.jb51.net/article/124438.htm" target="_blank" rel="noopener">资料原文</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function _parseInt(str, radix) &#123;</span><br><span class="line"> let str_type = typeof str;</span><br><span class="line"> let res = 0;</span><br><span class="line"> if (str_type !== &apos;string&apos; &amp;&amp; str_type !== &apos;number&apos;) &#123;</span><br><span class="line">  // 如果类型不是 string 或 number 类型返回NaN</span><br><span class="line">  return NaN</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 字符串处理</span><br><span class="line"> str = String(str).trim().split(&apos;.&apos;)[0]</span><br><span class="line"> let length = str.length;</span><br><span class="line"> if (!length) &#123;</span><br><span class="line">  // 如果为空则返回 NaN</span><br><span class="line">  return NaN</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if (!radix) &#123;</span><br><span class="line">  // 如果 radix 为0 null undefined</span><br><span class="line">  // 则转化为 10</span><br><span class="line">  radix = 10;</span><br><span class="line"> &#125;</span><br><span class="line"> if (typeof radix !== &apos;number&apos; || radix &lt; 2 || radix &gt; 36) &#123;</span><br><span class="line">  return NaN</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">  let arr = str.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">  res += Math.floor(arr[i]) * Math.pow(radix, i)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么的跨域，为什么会有跨域？"><a href="#什么的跨域，为什么会有跨域？" class="headerlink" title=" 什么的跨域，为什么会有跨域？"></a><center> 什么的跨域，为什么会有跨域？</center></h3><p><a href="https://www.jianshu.com/p/01654a4da9e5" target="_blank" rel="noopener">原文来源</a></p>
<ul>
<li>什么是跨域？<br>简单地理解就是因为JavaScript同源策略的限制，如 a.com 下的js 无法和b.com 的js通信。这是浏览器为了安全而设定的策略。<br>只有域名相同才不会有跨域的情况。<br>以下情况都会出现跨域：<br>特别注意两点：<br>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的，只能通过后台代理。<br>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上，“URL的首部”指https://（协议）</li>
<li>常见的情况和解决方案<br>1 .jsonp跨域访问接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在a.com下</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;b.com/getjson&apos;?cb=?$a=1&amp;b=2, // cb=? jquery的jsonp 会把此处的？</span><br><span class="line">    type: &apos;jsonp&apos;,                     //替换为jsonpCallback</span><br><span class="line">    jsonpCallback:&apos;jsonpCallback&apos;,  // 发出的请求为b.com/getjson&apos;?cb=jsonpCallback$a=1&amp;b=2</span><br><span class="line">    success:function(data)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>jsonp的原理：<br>虽然js是受到同源策略，但是引用js文件，img，css文件是不会受到限制的，所以原理就是动态创建script，jquery在发送请求前生产了一个jsonpCallback函数，然后向b.com请求了一个js文件。<br>服务器根据cb的值返回一个jsonpCallback(jsonDate)，即这个js文件被浏览器解析后执行了之前定义的函数。</p>
<p>缺点：<br>1 需要后端配合提供jsonp端口<br>2 因为是动态创建script标签，所以只能get，不能Post。安全性要大大低于post，不适合发送机密信息。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: '',
  alipayImage: ''
});
</script>
      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/04/20/JS跨域之JSONP方式/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JS跨域之JSONP方式
        
      </div>
    </a>
  
  
    <a href="/2018/04/17/JS 数组操作之源码分析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JS 数组操作之源码分析</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#图片懒加载"><span class="nav-number">1.</span> <span class="nav-text"> 图片懒加载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么叫图片懒加载？"><span class="nav-number">1.0.1.</span> <span class="nav-text">- 什么叫图片懒加载？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要使用这个技术？"><span class="nav-number">1.0.2.</span> <span class="nav-text">- 为什么要使用这个技术？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#怎么实现？"><span class="nav-number">1.0.3.</span> <span class="nav-text">- 怎么实现？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件委托和事件捕获"><span class="nav-number">2.</span> <span class="nav-text"> 事件委托和事件捕获</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述"><span class="nav-number">2.0.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件委托的原理："><span class="nav-number">2.0.2.</span> <span class="nav-text"> 事件委托的原理：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件捕获的执行顺序"><span class="nav-number">3.</span> <span class="nav-text"> 事件捕获的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS数组方法"><span class="nav-number">4.</span> <span class="nav-text"> JS数组方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#join"><span class="nav-number">4.0.1.</span> <span class="nav-text"> join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reverse"><span class="nav-number">4.0.2.</span> <span class="nav-text"> reverse()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort"><span class="nav-number">4.0.3.</span> <span class="nav-text"> sort()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cancat"><span class="nav-number">4.0.4.</span> <span class="nav-text"> cancat()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#slice-start-end"><span class="nav-number">4.0.5.</span> <span class="nav-text"> slice(start,end)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#splice"><span class="nav-number">4.0.6.</span> <span class="nav-text"> splice()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除的用法，array-splice-starti-n-，其中starti的含义是从哪个位置开始，n指的是需要删除的个数。"><span class="nav-number">4.0.7.</span> <span class="nav-text">删除的用法，array.splice(starti,n)，其中starti的含义是从哪个位置开始，n指的是需要删除的个数。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入的用法，array-splice-starti，0，值1，值2……-，其中0表示删除0个元素，值1和值2表示需要插入的值。"><span class="nav-number">4.0.8.</span> <span class="nav-text">插入的用法，array.splice(starti，0，值1，值2……)，其中0表示删除0个元素，值1和值2表示需要插入的值。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#替换的用法，array-splice-starti，n，值1，值2-，在需要替换的位置先删除，然后再插入值"><span class="nav-number">4.0.9.</span> <span class="nav-text">替换的用法，array.splice(starti，n，值1，值2)，在需要替换的位置先删除，然后再插入值~</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#把数组当栈使用"><span class="nav-number">4.1.</span> <span class="nav-text"> 把数组当栈使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现拖拽功能"><span class="nav-number">5.</span> <span class="nav-text"> 实现拖拽功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Gulp的功能"><span class="nav-number">6.</span> <span class="nav-text"> 实现Gulp的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用功能及其插件"><span class="nav-number">6.0.1.</span> <span class="nav-text">- 常用功能及其插件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#promise的实现原理"><span class="nav-number">7.</span> <span class="nav-text"> promise的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack"><span class="nav-number">8.</span> <span class="nav-text"> webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-出口"><span class="nav-number">8.0.1.</span> <span class="nav-text">2 出口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅克隆和深克隆和ES6的Symbol"><span class="nav-number">9.</span> <span class="nav-text"> 浅克隆和深克隆和ES6的Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#针对ES6新增的Symbol类型来探讨一下浅拷贝和深拷贝"><span class="nav-number">9.0.1.</span> <span class="nav-text">- 针对ES6新增的Symbol类型来探讨一下浅拷贝和深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手写parseInt的实现："><span class="nav-number">10.</span> <span class="nav-text"> 手写parseInt的实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么的跨域，为什么会有跨域？"><span class="nav-number">11.</span> <span class="nav-text"> 什么的跨域，为什么会有跨域？</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2018 - 2018 送你回家 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            送你回家
          </div>
          <div class="panel-body">
            Copyright © 2018 smilay All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>